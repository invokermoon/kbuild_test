# =============================================================================
# Build a target in the specified source directory
# Usage:
# 	make -f Makefile.build SRC=<SRC>          \
# 	                       OUT=<OUT>          \
# 	                       KCONFIG=<KCONFIG>  \
# 	                       INC_ROOT=<INC_ROOT>
# Where:
#  <SRC>        is the directory you want to build, relative from the tree top
#  <OUT>        is the path to the out-of-tree build directory
#  <KCONFIG>    is the path to the Kconfig file (name included)
#  <INC_ROOT>   is the path to the root include directories
# =============================================================================

# This is the default target, that will eventually trigger everything
all:
	$(AT)true

ifndef SRC
$(error No source directory (SRC) specified)
endif

ifndef OUT
$(error No output directory (OUT) specified)
endif

ifndef KCONFIG
$(error No Kconfig file (KCONFIG) specified)
endif

# If no include root path specfied, assume default
INC_ROOT ?= $(CURDIR)/include
ANSI_OFF="\033[m"
ANSI_RED="\033[0;32;31m"
ANSI_LIGHT_RED="\033[1;31m"
ANSI_GREEN="\033[0;32;32m"
ANSI_BLUE="\033[0;32;34m"
ANSI_BROWN="\033[0;33m"
ANSI_YELLOW="\033[1;33m"
ANSI_WHITE="\033[1;37m"




# All targets added to the PHONY variable will end up in .PHONY
# DO NOT add targets that are actual files to this: if you want a target to be
# built everytime, add the predefined FORCE target below as a dependency
PHONY := FORCE

# =============================================================================
# Step 1: Load build configuration
#
# The build configuration for this specific directory is contained in:
# - the global configuration file generated by Kconfig
# - the specific Kbuild.mk file defining rules for this directory
# =============================================================================

# Reset Kconfig variables so
# 1) they have correct type
# 2) they do not inherit any value from the environment
obj-y :=
cflags-y :=

# Read Kconfig's configuration file
include $(KCONFIG)

# Include local build configuration file if it exists, otherwise ignore
-include $(SRC)/Kbuild.mk

# =============================================================================
# Step 2: Check build configuration
#
# Evaluate what's to be done for that SRC based on what's in the obj-y
# variable populated by Kbuild.mk with the help of Kconfig's auto.conf
#
# The input of this phase is contained in:
# - obj-y:
#   A list of local object files and directories
#
# The output of this phase is contained in:
# - obj-y:
#   A list of objects and archives to be bundled into a built-in.a "thin" archive
#   which contains references to the original objects under this directory tree
# - subdir-obj-y:
#   A list of dir/built-in.a to be obtained as a result of the recursive
#   conditional build of each subdirectory of the current directory
# - subdir-y:
#   The actual list of subdirectories to descend into to produce subdir-obj-y
# =============================================================================
#test##
$(info  OBJ BUILD****************************************)
$(info )

$(info [0]subdir-y:$(subdir-y))
$(info [0]subdir-obj-y:$(subdir-obj-y))
$(info [0]obj-y:$(obj-y))

# First, identify if there are any directories specifed in obj-y that we need
# to descend into
__subdir-y	:= $(patsubst %/,%,$(filter %/, $(obj-y)))
subdir-y	+= $(__subdir-y)
subdir-y	:= $(sort $(subdir-y))

$(info [1]subdir-y:$(subdir-y))
$(info [1]subdir-obj-y:$(subdir-obj-y))
$(info [1]obj-y:$(obj-y))


# Remove possible absolute project path prefix, as another absolute prefix will be added
obj-y		:= $(obj-y:$(T)/%=%)
$(info [2]subdir-y:$(subdir-y))
$(info [2]subdir-obj-y:$(subdir-obj-y))
$(info [2]obj-y:$(obj-y))


# Next, update the list of objects, replacing any specified directory by the
# aggregated thin archive that will be produced when descending into it
obj-y		:= $(patsubst %/, %/built-in.a, $(obj-y))
$(info [3]subdir-y:$(subdir-y))
$(info [3]subdir-obj-y:$(subdir-obj-y))
$(info [3]obj-y:$(obj-y))


# Remember the list of these aggregated archives, that will be used as a dependency
# to trigger the recursion into subdirectories
subdir-obj-y := $(filter %/built-in.a, $(obj-y))
$(info [4]subdir-y:$(subdir-y))
$(info [4]subdir-obj-y:$(subdir-obj-y))
$(info [4]obj-y:$(obj-y))


# Prepend subdirs (absolute dirs are omitted) with the absolute SRC path
#test##
subdir-y := $(filter /%,$(subdir-y)) \
            $(addprefix $(SRC)/,$(filter-out /%,$(subdir-y)))
$(info [5]subdir-y:$(subdir-y))
$(info [5]subdir-obj-y:$(subdir-obj-y))
$(info [5]obj-y:$(obj-y))


# Concatenate OUT and SRC without the absolute path to the project
OUT_SRC := $(abspath $(OUT)/$(SRC:$(T)/%=%))
$(info [6]subdir-y:$(subdir-y))
$(info [6]subdir-obj-y:$(subdir-obj-y))
$(info [6]obj-y:$(obj-y))
$(info [6]OUT:$(OUT))
$(info [6]SRC:$(SRC))
$(info [6]OUT_SRC:$(OUT_SRC))


# Prepend the objects and archives with the actual build SRC
obj-y		:= $(addprefix $(OUT_SRC)/,$(obj-y))
subdir-obj-y := $(addprefix $(OUT_SRC)/,$(subdir-obj-y))
#eg: obj-y += XXX.so   XXX-obj-y :=XXX.o XXX.o
#result: modules-obj-y=$(path)/=XXX.o $(path)/=XXX.o
modules-obj-y :=$(if $(filter %.so, $(obj-y)),$(addprefix $(OUT_SRC)/, $($(obj-y:$(OUT_SRC)/%.so=%-obj-y))),)
$(info [7]modules-obj-y:$(modules-obj-y))
$(info [7]y:$($(obj-y:$(OUT_SRC)/%.so=%-obj-y)))
$(info [7]subdir-y:$(subdir-y))
$(info [7]subdir-obj-y:$(subdir-obj-y))
$(info [7]obj-y:$(obj-y))
$(info )
$(info  OBJ BUILD****************************************)


ifneq ($(VERBOSE),)
$(info Thunderdome kbuild processed: pwd=$(CURDIR) src=$(SRC) out=$(OUT:$(T)/%/kbuild=%))
$(info -   subdirs-y: $(subdir-y))
$(info -   obj-y: $(obj-y))
$(info -   subdir-obj-y: $(subdir-obj-y))
endif

# =============================================================================
# Step 3: Define rules to descend into subdirectories
# =============================================================================

# Tell make to descend into subdirs to build the corresponding archives
# Compilation flags specified using subdir-cflags-y are passed recursively
$(sort $(subdir-obj-y)): $(subdir-y) ;

PHONY += $(subdir-y)
$(subdir-y):
	@[ "$(VERBOSE)" ] && echo "Descending into directory $@" || true
	$(AT)$(MAKE) -f build/Makefile.build \
		SRC=$@ \
		OUT=$(OUT) \
		KCONFIG=$(KCONFIG) \
		INC_ROOT=$(INC_ROOT) \
		CFLAGS="$(CFLAGS) $(subdir-cflags-y)"

# =============================================================================
# Step 4: Define rules to build objects in this directory
# =============================================================================

# Include dependency files that may have been produced by a previous build
-include $(OUT_SRC)/*.d

# Compute CFLAGS to be applied on all files in this directory, based on:
# - the existing CFLAGS that may have been passed to us on the make command
# - the cflags-y and subdir-cflags-y defined in the local Kbuild.mk
# Note: per-file flags can also be set using the CFLAGS_<file>.o syntax
COMPUTED_CFLAGS := $(CFLAGS) $(subdir-cflags-y) $(cflags-y)
# We may not be compiling from the directory itself, so add it to the include
# search path, and prefix current dir if path is relative
COMPUTED_CFLAGS += -I$(if $(filter /%, $(SRC)),,$(CURDIR)/)$(SRC)
# Also add the top-level include directive
COMPUTED_CFLAGS += -I$(INC_ROOT)
# Also add the path to the global configuration header
COMPUTED_CFLAGS += -I$(OUT)/config
# Tell gcc to generate dependency files
COMPUTED_CFLAGS += -MD

# Create directory
$(OUT_SRC):
	@echo $(ANSI_RED)"[kMD]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)mkdir -p $@

# Build C files
$(OUT_SRC)/%.o: $(SRC)/%.c $(OUT_SRC)/c.flags
	@echo $(ANSI_RED)"[kCC]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -c -o $@ $<

# Build C files
$(OUT_SRC)/%.so: $(modules-obj-y)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -shared -fPIC $^ -o $@


# Build S file (assembly)
$(OUT_SRC)/%.o: $(SRC)/%.s $(OUT_SRC)/c.flags
	@echo $(ANSI_RED)"[kAS]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -c -o $@ $<

# Build S file (assembly with pre-processor)
$(OUT_SRC)/%.o: $(SRC)/%.S $(OUT_SRC)/c.flags
	@echo $(ANSI_RED)"[kAS+P]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -c -o $@ $<

# Create an aggregated thin archive
$(OUT_SRC)/built-in.a: $(obj-y) | $(OUT_SRC)
	@echo $(ANSI_RED)"[kAR]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)rm -f $@
	$(AT)$(AR) -rcT $@ $(obj-y)



# Remember CFLAGS used to compile files in this directory
$(OUT_SRC)/c.flags: $(KCONFIG) | $(OUT_SRC)
	$(AT)echo '$(COMPUTED_CFLAGS)' | cmp -s - $@ || echo '$(COMPUTED_CFLAGS)' > $@

# =============================================================================
# Step 5: Let's build
# =============================================================================

all: $(OUT_SRC)/built-in.a

.PHONY: $(PHONY)
